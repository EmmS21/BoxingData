"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoxrecRequests = void 0;
var cheerio = require("cheerio");
var FormData = require("form-data");
var boxrec_requests_constants_1 = require("./boxrec-requests.constants");
var helpers_1 = require("./helpers");
// used to hold the dynamic param on BoxRec to prevent multiple unnecessary requests
// todo these should all be time based or on failure update these values.
// todo A node process not restarted will start getting failures
var searchParamWrap = "";
var resultsParamWrap = "";
var titlesParamWrap = "";
var ratingsParamWrap = "";
var quickSearchParamWrap = "";
var createParamsObject = function (params, prefix) {
    var qs = {};
    for (var i in params) {
        if (params.hasOwnProperty(i)) {
            qs["".concat(prefix, "[").concat(i, "]")] = params[i];
        }
    }
    return qs;
};
/**
 * Makes API requests to BoxRec and returns the HTML body
 */
var BoxrecRequests = /** @class */ (function () {
    function BoxrecRequests() {
    }
    /**
     * Makes a request to get Bout Information
     * @param cookies       contains cookie information about the user
     * @param eventBoutId   includes both the event and bout separated by "/"
     */
    BoxrecRequests.getBout = function (cookies, eventBoutId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/event/".concat(eventBoutId), cookies)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to return/save the PDF version of a boxer profile
     * @param cookies      contains cookie information about the user
     * @param globalId     the BoxRec global id of the boxer
     * @returns {Promise<string>}
     */
    BoxrecRequests.getBoxerPDF = function (cookies, globalId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, BoxrecRequests.getBoxerOther(cookies, globalId, "pdf")];
            });
        });
    };
    /**
     * Makes a request to BoxRec to return/save the printable version of a boxer profile
     * @param cookies      contains cookie information about the user
     * @param globalId     the BoxRec global id of the boxer
     * @returns {Promise<string>}
     */
    BoxrecRequests.getBoxerPrint = function (cookies, globalId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, BoxrecRequests.getBoxerOther(cookies, globalId, "print")];
            });
        });
    };
    /**
     * Makes a request to BoxRec to return a list of current champions
     * @param cookies      contains cookie information about the user
     * @returns {Promise<string>}
     */
    BoxrecRequests.getChampions = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/champions", cookies)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to get events/bouts on the particular date
     * @param cookies               contains cookie information about the user
     * @param {BoxrecDate} params
     * @returns {Promise<void>}
     */
    BoxrecRequests.getDate = function (cookies, params) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/date", cookies, {
                        "d[date][day]": params.day,
                        "d[date][month]": params.month,
                        "d[date][year]": params.year,
                        "sport": params.sport,
                    })];
            });
        });
    };
    /**
     * Makes a request to BoxRec to retrieve an event by id
     * @param cookies               contains cookie information about the user
     * @param {number} eventId      the event id from BoxRec
     * @returns {Promise<string>}
     */
    BoxrecRequests.getEventById = function (cookies, eventId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/event/".concat(eventId), cookies)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to list events by sport/location
     * @param cookies                               contains cookie information about the user
     * @param {BoxrecLocationEventParams} params    params included to get events by location
     * @param {number} offset                       the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getEvents = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, BoxrecRequests.getEventsByLocation(cookies, params, offset)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to list events by sport/location
     * @deprecated              This method is now more than location, and is also by sport (use `getPeople`)
     * @param cookies                               contains cookie information about the user
     * @param {BoxrecLocationEventParams} params    params included to get events by location
     * @param {number} offset                       the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getEventsByLocation = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var qs;
            return __generator(this, function (_a) {
                qs = createParamsObject(params, "l");
                qs.offset = offset;
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/locations/event", cookies, qs)];
            });
        });
    };
    /**
     * Make a request to BoxRec to search for people by location/role
     * @param cookies                               contains cookie information about the user
     * @param {BoxrecLocationsPeopleParams} params  params included to get people by location/role
     * @param {number} offset                       the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getPeople = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, BoxrecRequests.getPeopleByLocation(cookies, params, offset)];
            });
        });
    };
    /**
     * Make a request to BoxRec to search for people by location/role
     * @deprecated              This method is now more than location, and is also by sport (use `getPeople`)
     * @param cookies                               contains cookie information about the user
     * @param {BoxrecLocationsPeopleParams} params  params included to get people by location
     * @param {number} offset                       the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getPeopleByLocation = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var qs;
            return __generator(this, function (_a) {
                qs = createParamsObject(params, "l");
                qs.offset = offset;
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/locations/people", cookies, qs)];
            });
        });
    };
    /**
     * Makes a search request to BoxRec to get all people that match that name
     * by using a generator, we're able to prevent making too many calls to BoxRec
     * @param cookies                       contains cookie information about the user
     * @param {string} firstName            the person's first name
     * @param {string} lastName             the person's last name
     * @param {string} role                 the role of the person
     * @param {BoxrecStatus} status         whether the person is active in Boxing or not
     * @param {number} offset               the number of rows to offset the search
     * @yields {string}                     returns a generator to fetch the next person by ID
     */
    BoxrecRequests.getPeopleByName = function (cookies, firstName, lastName, role, status, offset) {
        if (role === void 0) { role = ""; }
        if (status === void 0) { status = boxrec_requests_constants_1.BoxrecStatus.all; }
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var params;
            return __generator(this, function (_a) {
                params = {
                    first_name: firstName,
                    last_name: lastName,
                    role: role,
                    status: status,
                };
                return [2 /*return*/, BoxrecRequests.search(cookies, params, offset)];
            });
        });
    };
    /**
     * Make a request to BoxRec to get a person by their BoxRec Global ID
     * @param cookies                           contains cookie information about the user
     * @param {number} globalId                 the BoxRec profile id
     * @param {BoxrecRole} role                 the role of the person in boxing (there are multiple profiles for people if they fall under different roles)
     * @param {number} offset                   offset number of bouts/events in the profile.  todo boxer support?
     * @returns {Promise<string>}
     */
    BoxrecRequests.getPersonById = function (cookies, globalId, role, offset) {
        if (role === void 0) { role = null; }
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (role !== null) {
                    return [2 /*return*/, BoxrecRequests.makeGetPersonByIdRequest(cookies, globalId, role, offset, null)];
                }
                // if role is null we need to get the default profile, we `quick_search` it which will give us the default
                return [2 /*return*/, BoxrecRequests.quickSearch(cookies, globalId)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to get a list of ratings/rankings, either P4P or by a single weight class
     * @param cookies                           contains cookie information about the user
     * @param {BoxrecRatingsParams} params      params included to get ratings
     * @param {number} offset                   the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getRatings = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var paramWrap, qs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, BoxrecRequests.getRatingsParamWrap(cookies)];
                    case 1:
                        paramWrap = _a.sent();
                        qs = createParamsObject(params, paramWrap);
                        qs.offset = offset;
                        return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/ratings", cookies, qs)];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to get a list of results.
     * Uses same class
     * @param cookies                       contains cookie information about the user
     * @param {BoxrecResultsParams} params  params included to get results
     * @param {number} offset               the number of rows to offset this search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getResults = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var qs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, BoxrecRequests.buildResultsSchedulesParams(cookies, params, offset)];
                    case 1:
                        qs = _a.sent();
                        return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/results", cookies, qs)];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to get a list of scheduled events
     * @param cookies                           contains cookie information about the user
     * @param {BoxrecScheduleParams} params     params included to get schedule
     * @param {number} offset                   the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getSchedule = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var qs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, BoxrecRequests.buildResultsSchedulesParams(cookies, params, offset)];
                    case 1:
                        qs = _a.sent();
                        return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/schedule", cookies, qs)];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to list all the scores of the user
     * @param cookies                            contains cookie information about the user
     * @returns {Promise<string>}
     */
    BoxrecRequests.listScores = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/my_scores", cookies)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to list all the scores of a single bout (including the user and fans)
     * @param cookies                           contains cookie information about the user
     * @param boutId                            the ID of the bout
     * @returns {Promise<string>}
     */
    BoxrecRequests.getScoresByBoutId = function (cookies, boutId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/scoring/".concat(boutId), cookies)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to update the user's score of a bout
     * @param cookies                           contains cookie information about the user
     * @param boutId                            the ID of the bout
     * @param scorecard                         an array of numbers that represent the points for each fighter per round
     * @returns {Promise<string>}
     */
    BoxrecRequests.updateScoreByBoutId = function (cookies, boutId, scorecard) {
        return __awaiter(this, void 0, void 0, function () {
            var qs;
            return __generator(this, function (_a) {
                qs = {};
                scorecard.forEach(function (round, idx) {
                    qs["a".concat(idx + 1)] = "" + round[0];
                    qs["b".concat(idx + 1)] = "" + round[1];
                });
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/scoring/historical/submit/".concat(boutId), cookies, qs)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to the specific title URL to get a belt's history
     * @param cookies               contains cookie information about the user
     * @param {string} titleString  in the format of "6/Middleweight" which would be the WBC Middleweight title
     * @param {number} offset       the number of rows to offset the search
     * @returns {Promise<string>}
     * @todo offset not used?  Does this link work?
     */
    BoxrecRequests.getTitleById = function (cookies, titleString, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/title/".concat(titleString), cookies)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to get information on scheduled title fights
     * @param cookies                contains cookie information about the user
     * @param params
     * @param offset
     */
    BoxrecRequests.getTitles = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var paramWrap, qs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, BoxrecRequests.getTitlesParamWrap(cookies)];
                    case 1:
                        paramWrap = _a.sent();
                        qs = createParamsObject(params, paramWrap);
                        qs.offset = offset;
                        return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/titles", cookies, qs)];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to get the information of a venue
     * @param cookies           contains cookie information about the user
     * @param {number} venueId
     * @param {number} offset   the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.getVenueById = function (cookies, venueId, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/venue/".concat(venueId), cookies, {
                        offset: offset,
                    })];
            });
        });
    };
    /**
     * Lists the boxers that the user is watching
     * @param {request.CookieJar} cookies
     * @returns {Promise<string>}
     */
    BoxrecRequests.getWatched = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/watchlist", cookies)];
            });
        });
    };
    /**
     * Makes a request to BoxRec to log the user in
     * This is required before making any additional calls
     * The session cookie is stored inside this instance of the class
     * @param {string} username     your BoxRec username
     * @param {string} password     your BoxRec password
     * @returns     If the response is a string, you have successfully logged in.  Otherwise an error should be thrown
     */
    BoxrecRequests.login = function (username, password) {
        return __awaiter(this, void 0, void 0, function () {
            var formData, data, cookies, redirectUrl, loginRedirect, loginRedirectBody, $;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // check for undefined args, if undefined will throw weird error.  Therefore we check and throw proper error
                        // https://github.com/form-data/form-data/issues/336#issuecomment-301116262
                        if (username === undefined || password === undefined) {
                            throw new Error("missing parameter: ".concat(username === undefined ? "username" : "password"));
                        }
                        formData = new FormData();
                        formData.append("_password", password);
                        formData.append("_remember_me", "on");
                        formData.append("_target_path", "https://boxrec.com"); // not required,
                        formData.append("_username", username);
                        formData.append("login[go]", ""); // not required
                        return [4 /*yield*/, (0, helpers_1.requestWrapperFullResponse)("https://boxrec.com/en/login", undefined, {
                                body: formData,
                                cache: "no-cache",
                                credentials: "same-origin",
                                method: "POST",
                                mode: "no-cors",
                                redirect: "manual",
                            })];
                    case 1:
                        data = _a.sent();
                        cookies = data.headers.get("set-cookie");
                        redirectUrl = data.headers.get("Location");
                        if (!redirectUrl) {
                            throw new Error("Could not get redirect URL");
                        }
                        return [4 /*yield*/, (0, helpers_1.requestWrapperFullResponse)(redirectUrl, cookies, {})];
                    case 2:
                        loginRedirect = _a.sent();
                        return [4 /*yield*/, loginRedirect.text()];
                    case 3:
                        loginRedirectBody = _a.sent();
                        // if the user hasn't given consent, the user is redirected to a page that contains `gdpr`
                        if (redirectUrl === null || redirectUrl === void 0 ? void 0 : redirectUrl.includes("gdpr")) {
                            throw new Error("GDPR consent is needed with this account.  Log into BoxRec through their website and accept before using this account");
                        }
                        $ = cheerio.load(loginRedirectBody);
                        if ($("input#username").length) {
                            throw new Error("Please check your credentials, could not log into BoxRec");
                        }
                        if (loginRedirect.status !== 200) {
                            throw new Error("Redirect status was expecting 200");
                        }
                        return [2 /*return*/, cookies];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to search people by
     * Note: currently only supports boxers
     * @param cookies                       contains cookie information about the user
     * @param {BoxrecSearchParams} params   params included in this search
     * @param {number}             offset   the number of rows to offset the search
     * @returns {Promise<string>}
     */
    BoxrecRequests.search = function (cookies, params, offset) {
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var searchParam, qs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!params.first_name && !params.last_name) {
                            // BoxRec says 2 or more characters, it's actually 3 or more
                            throw new Error("Requires `first_name` or `last_name` - minimum 3 characters long");
                        }
                        return [4 /*yield*/, BoxrecRequests.getSearchParamWrap(cookies)];
                    case 1:
                        searchParam = _a.sent();
                        qs = createParamsObject(params, searchParam);
                        qs.offset = offset;
                        return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/search", cookies, qs)];
                }
            });
        });
    };
    /**
     * Removes the boxer from the users watch list.  Returns the watch page where the boxer should be removed
     * @param cookies    contains cookie information about the user
     * @param {number} boxerGlobalId
     * @returns {Promise<boolean>}
     */
    BoxrecRequests.unwatch = function (cookies, boxerGlobalId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/unwatch/".concat(boxerGlobalId), cookies)];
            });
        });
    };
    /**
     * Adds the boxer to the users watch list.  Returns the watch page where the boxer should have been added
     * @param cookies    contains cookie information about the user
     * @param {number} boxerGlobalId
     * @returns {Promise<boolean>}
     */
    BoxrecRequests.watch = function (cookies, boxerGlobalId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/watch/".concat(boxerGlobalId), cookies)];
            });
        });
    };
    /**
     * Search for global ID or string
     * better for searching by global ID.  `search` doesn't have it
     * @param cookies
     * @param globalIdOrSearchText
     * @param searchRole    By default this is empty and returns the default role of the user
     */
    BoxrecRequests.quickSearch = function (cookies, globalIdOrSearchText, searchRole) {
        if (searchRole === void 0) { searchRole = ""; }
        return __awaiter(this, void 0, void 0, function () {
            var searchParam, formData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, BoxrecRequests.getQuickSearchParamWrap(cookies)];
                    case 1:
                        searchParam = _a.sent();
                        formData = new FormData();
                        formData.append("".concat(searchParam, "[search_role]"), searchRole === null ? "" : searchRole);
                        formData.append("".concat(searchParam, "[search_text]"), globalIdOrSearchText);
                        return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/quick_search", cookies, {
                                body: formData,
                                method: "POST",
                            })];
                }
            });
        });
    };
    BoxrecRequests.buildResultsSchedulesParams = function (cookies, params, offset) {
        return __awaiter(this, void 0, void 0, function () {
            var searchParam, qs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, BoxrecRequests.getResultsParamWrap(cookies)];
                    case 1:
                        searchParam = _a.sent();
                        qs = createParamsObject(params, searchParam);
                        qs.offset = offset;
                        return [2 /*return*/, qs];
                }
            });
        });
    };
    /**
     * Returns/saves a boxer's profile in print/pdf format
     * @param cookies                       contains cookie information about the user
     * @param {number} globalId
     * @param {"pdf" | "print"} type
     * @todo support role as it's not just boxers (ex. amateurs)
     * @returns {Promise<string>}
     */
    BoxrecRequests.getBoxerOther = function (cookies, globalId, type) {
        return __awaiter(this, void 0, void 0, function () {
            var qs;
            return __generator(this, function (_a) {
                qs = {};
                if (type === "pdf") {
                    qs.pdf = "y";
                }
                else {
                    qs.print = "y";
                }
                return [2 /*return*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/proboxer/".concat(globalId), cookies, qs)];
            });
        });
    };
    BoxrecRequests.getRatingsParamWrap = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            var boxrecPageBody, $;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(ratingsParamWrap === "")) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/ratings", cookies)];
                    case 1:
                        boxrecPageBody = _a.sent();
                        $ = cheerio.load(boxrecPageBody);
                        ratingsParamWrap = $(".page form").attr("name") || "";
                        _a.label = 2;
                    case 2: return [2 /*return*/, ratingsParamWrap];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to get the search param prefix that is wrapped around params for the `results` page
     * @param cookies
     */
    BoxrecRequests.getResultsParamWrap = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            var boxrecPageBody, $;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(resultsParamWrap === "")) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/results", cookies)];
                    case 1:
                        boxrecPageBody = _a.sent();
                        $ = cheerio.load(boxrecPageBody);
                        resultsParamWrap = $(".page form").attr("name") || "";
                        _a.label = 2;
                    case 2: return [2 /*return*/, resultsParamWrap];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to find out the quick search param prefix that is wrapped around params
     * @param cookies
     */
    BoxrecRequests.getQuickSearchParamWrap = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            var boxrecPageBody, $;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(quickSearchParamWrap === "")) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/quick_search", cookies)];
                    case 1:
                        boxrecPageBody = _a.sent();
                        $ = cheerio.load(boxrecPageBody);
                        quickSearchParamWrap = $(".navLinks form").attr("name") || "";
                        _a.label = 2;
                    case 2: return [2 /*return*/, quickSearchParamWrap];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to find out the search param prefix that is wrapped around params
     * @param cookies
     */
    BoxrecRequests.getSearchParamWrap = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            var boxrecPageBody, $;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(searchParamWrap === "")) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/search", cookies)];
                    case 1:
                        boxrecPageBody = _a.sent();
                        $ = cheerio.load(boxrecPageBody);
                        searchParamWrap = $("h2:contains('Find People')")
                            .parents("td").find("form").attr("name") || "";
                        _a.label = 2;
                    case 2: return [2 /*return*/, searchParamWrap];
                }
            });
        });
    };
    /**
     * Makes a request to BoxRec to get the titles param prefix that is wrapped around params for the `titles` page
     * @param cookies
     */
    BoxrecRequests.getTitlesParamWrap = function (cookies) {
        return __awaiter(this, void 0, void 0, function () {
            var boxrecPageBody, $;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(titlesParamWrap === "")) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, helpers_1.requestWrapper)("https://boxrec.com/en/titles", cookies)];
                    case 1:
                        boxrecPageBody = _a.sent();
                        $ = cheerio.load(boxrecPageBody);
                        titlesParamWrap = $(".page form").attr("name") || "";
                        _a.label = 2;
                    case 2: return [2 /*return*/, titlesParamWrap];
                }
            });
        });
    };
    /**
     * Returns the number of table columns on the page in dataTables
     * Note: Due to the selector be lazy and the poor HTML structure on BoxRec, this selector also includes other tables
     *      like enrollments.  We don't care about that though, we're just comparing the page with toggleRatings to get
     *      the most columns we can
     * @param boxrecPageBody
     */
    BoxrecRequests.numberOfTableColumns = function (boxrecPageBody) {
        var $ = cheerio.load(boxrecPageBody);
        return $(".dataTable tbody:nth-child(2) tr:nth-child(1) td").length;
    };
    /**
     *
     * @param cookies
     * @param globalId
     * @param role
     * @param offset        offset is the number of bouts/events on a person's profile (not tested with boxers)
     * @param previousRequestBody  we'll compare both requests and return the one with more columns
     *                                          the reason for this is because it's hard to determine and keep up
     *                                          BoxRec column changes, therefore we just take the one with most columns
     */
    BoxrecRequests.makeGetPersonByIdRequest = function (cookies, globalId, role, offset, previousRequestBody) {
        if (role === void 0) { role = boxrec_requests_constants_1.BoxrecRole.proBoxer; }
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var url, qs, boxrecPageBody, numberOfColumnsReceived, numberOfColumnsReceivedPrevious;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = "https://boxrec.com/en/".concat(role, "/").concat(globalId);
                        qs = {
                            offset: offset,
                        };
                        // we made the same request before therefore we toggle ratings to see the difference
                        if (previousRequestBody) {
                            qs.toggleRatings = "y";
                        }
                        return [4 /*yield*/, (0, helpers_1.requestWrapper)(url, cookies, qs)];
                    case 1:
                        boxrecPageBody = _a.sent();
                        numberOfColumnsReceived = BoxrecRequests.numberOfTableColumns(boxrecPageBody);
                        // if the profile does not match what we expected (returns something different),
                        // we make the other request for data
                        // ex. getPersonById `52984` boxer Paulie Malignaggi
                        // if we don't specify a role, it'll give his `pro boxer` career
                        // if we do specify a role that he doesn't have like `muay thai boxer`,
                        // it'll return his `bare knuckle boxing` career
                        // there is a test for this
                        if ((0, helpers_1.getRoleOfHTML)(boxrecPageBody) !== role) {
                            // throw an error so we don't deceive the developer/user what type of profile this is
                            throw new Error("Person does not have this role");
                        }
                        if (previousRequestBody) {
                            numberOfColumnsReceivedPrevious = BoxrecRequests.numberOfTableColumns(previousRequestBody);
                            // if the previous request has more columns, we return that body instead
                            return [2 /*return*/, numberOfColumnsReceivedPrevious > numberOfColumnsReceived
                                    ? previousRequestBody : boxrecPageBody];
                        }
                        // calls itself with the toggle for `toggleRatings=y`
                        return [2 /*return*/, this.makeGetPersonByIdRequest(cookies, globalId, role, offset, boxrecPageBody)];
                }
            });
        });
    };
    return BoxrecRequests;
}());
exports.BoxrecRequests = BoxrecRequests;
//# sourceMappingURL=boxrec-requests.js.map